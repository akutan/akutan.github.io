---
layout: post
title:  "3D Kreuz mit Verbindungen"
date:   2025-09-27 10:00:00 +0200
categories: Kunst
tags: 3D
description: Dreidimensionales Kreuz mit Verbindungen
---

<div class="info">
    <p style="color: #666; text-align: center; margin-bottom: 20px;">Drag to rotate â€¢ Mouse wheel to zoom. Erst eine, dann zwei, dann drei Ebenen</p>
</div>

<div id="sketch-container"></div>
<div id="sketch-container2"></div>
<div id="sketch-container3"></div>

<style>
    #sketch-container, #sketch-container2, #sketch-container3 {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 50vh;
        margin: 20px 0;
        background-color: transparent;
    }
    .info {
        text-align: center;
        margin-bottom: 20px;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
<script>
    // First sketch - YZ plane diagonals only
    let sketch1 = function(p) {
        let L = 120;
        let pts = [];
        let edges = [];
        let N = 40;
        let rotX = 0, rotY = 0;
        let lastMouseX, lastMouseY;
        let zoom = 0;
        let autoRotate = true;
        let lastInteractionTime = 0;
        let diagColors = [];
        
        p.setup = function() {
            let canvas = p.createCanvas(600, 450, p.WEBGL);
            canvas.parent('sketch-container');
            
            diagColors = [
                p.color(255, 100, 100),
                p.color(100, 255, 120),
                p.color(120, 150, 255),
                p.color(255, 220, 120)
            ];
            
            pts = [
                p.createVector(L, 0, 0),
                p.createVector(-L, 0, 0),
                p.createVector(0, L, 0),
                p.createVector(0, -L, 0),
                p.createVector(0, 0, L),
                p.createVector(0, 0, -L)
            ];
            
            edges = [];
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    if (p.abs(p5.Vector.dot(pts[i], pts[j])) < 0.001) {
                        if (p.abs(pts[i].x) < 0.001 && p.abs(pts[j].x) < 0.001) {
                            if (pts[i].y < pts[j].y || (p.abs(pts[i].y - pts[j].y) < 0.001 && pts[i].z < pts[j].z)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        }
                    }
                }
            }
        }
        
        p.draw = function() {
            p.background(40, 40, 40);
            
            if (p.millis() - lastInteractionTime > 2000) {
                autoRotate = true;
            }
            
            if (autoRotate) {
                rotY += p.TWO_PI / 2400;
            }
            
            p.translate(0, 0, -50 + zoom);
            p.rotateX(rotX);
            p.rotateY(rotY);
            
            p.strokeWeight(5);
            p.stroke(0, 0, 0);
            for (let pt of pts) {
                p.line(0, 0, 0, pt.x, pt.y, pt.z);
            }
            
            p.strokeWeight(0.45);
            for (let idx = 0; idx < edges.length; idx++) {
                let e = edges[idx];
                let a = pts[e[0]];
                let b = pts[e[1]];
                let c = diagColors[idx];
                
                p.stroke(c);
                p.line(a.x, a.y, a.z, b.x, b.y, b.z);
                
                for (let i = 0; i <= N; i++) {
                    let t = i / N;
                    let dpt = p5.Vector.lerp(a, b, t);
                    
                    let axis = -1;
                    if (p.abs(a.x) < 0.001 && p.abs(b.x) < 0.001) axis = 0;
                    else if (p.abs(a.y) < 0.001 && p.abs(b.y) < 0.001) axis = 1;
                    else if (p.abs(a.z) < 0.001 && p.abs(b.z) < 0.001) axis = 2;
                    
                    let u = i / N;
                    let armPos, armNeg;
                    
                    if (axis == 0) {
                        armPos = p.createVector(L * u, 0, 0);
                        armNeg = p.createVector(-L * u, 0, 0);
                    }
                    else if (axis == 1) {
                        armPos = p.createVector(0, L * u, 0);
                        armNeg = p.createVector(0, -L * u, 0);
                    }
                    else {
                        armPos = p.createVector(0, 0, L * u);
                        armNeg = p.createVector(0, 0, -L * u);
                    }
                    
                    p.stroke(c);
                    p.line(dpt.x, dpt.y, dpt.z, armPos.x, armPos.y, armPos.z);
                    p.line(dpt.x, dpt.y, dpt.z, armNeg.x, armNeg.y, armNeg.z);
                }
            }
            
            p.push();
            p.camera();
            p.fill(255);
            p.textSize(12);
            p.textAlign(p.LEFT, p.TOP);
            p.text("YZ plane", -p.width/2 + 10, -p.height/2 + 10);
            p.pop();
        }
        
        p.mousePressed = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
                autoRotate = false;
                lastInteractionTime = p.millis();
            }
        }
        
        p.mouseDragged = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                autoRotate = false;
                lastInteractionTime = p.millis();
                let dx = (p.mouseX - lastMouseX) * 0.01;
                let dy = (p.mouseY - lastMouseY) * 0.01;
                rotY += dx;
                rotX += dy;
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
            }
        }
        
        p.mouseWheel = function(event) {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                zoom += event.delta * 5;
                return false;
            }
        }
    };
    
    // Second sketch - YZ + XZ planes
    let sketch2 = function(p) {
        let L = 120;
        let pts = [];
        let edges = [];
        let N = 40;
        let rotX = 0, rotY = 0;
        let lastMouseX, lastMouseY;
        let zoom = 0;
        let autoRotate = true;
        let lastInteractionTime = 0;
        let diagColors = [];
        
        p.setup = function() {
            let canvas = p.createCanvas(600, 450, p.WEBGL);
            canvas.parent('sketch-container2');
            
            diagColors = [
                p.color(255, 100, 100),
                p.color(100, 255, 120),
                p.color(120, 150, 255),
                p.color(255, 220, 120),
                p.color(255, 150, 200),
                p.color(150, 255, 255),
                p.color(200, 150, 255),
                p.color(255, 200, 100)
            ];
            
            pts = [
                p.createVector(L, 0, 0),
                p.createVector(-L, 0, 0),
                p.createVector(0, L, 0),
                p.createVector(0, -L, 0),
                p.createVector(0, 0, L),
                p.createVector(0, 0, -L)
            ];
            
            edges = [];
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    if (p.abs(p5.Vector.dot(pts[i], pts[j])) < 0.001) {
                        let isYZ = p.abs(pts[i].x) < 0.001 && p.abs(pts[j].x) < 0.001;
                        let isXZ = p.abs(pts[i].y) < 0.001 && p.abs(pts[j].y) < 0.001;
                        
                        if (isYZ) {
                            if (pts[i].y < pts[j].y || (p.abs(pts[i].y - pts[j].y) < 0.001 && pts[i].z < pts[j].z)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        } else if (isXZ) {
                            if (pts[i].x < pts[j].x || (p.abs(pts[i].x - pts[j].x) < 0.001 && pts[i].z < pts[j].z)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        }
                    }
                }
            }
        }
        
        p.draw = function() {
            p.background(40, 40, 40);
            
            if (p.millis() - lastInteractionTime > 2000) {
                autoRotate = true;
            }
            
            if (autoRotate) {
                rotY += p.TWO_PI / 2400;
            }
            
            p.translate(0, 0, -50 + zoom);
            p.rotateX(rotX);
            p.rotateY(rotY);
            
            p.strokeWeight(5);
            p.stroke(0, 0, 0);
            for (let pt of pts) {
                p.line(0, 0, 0, pt.x, pt.y, pt.z);
            }
            
            p.strokeWeight(0.45);
            for (let idx = 0; idx < edges.length; idx++) {
                let e = edges[idx];
                let a = pts[e[0]];
                let b = pts[e[1]];
                let c = diagColors[idx];
                
                p.stroke(c);
                p.line(a.x, a.y, a.z, b.x, b.y, b.z);
                
                for (let i = 0; i <= N; i++) {
                    let t = i / N;
                    let dpt = p5.Vector.lerp(a, b, t);
                    
                    let axis = -1;
                    if (p.abs(a.x) < 0.001 && p.abs(b.x) < 0.001) axis = 0;
                    else if (p.abs(a.y) < 0.001 && p.abs(b.y) < 0.001) axis = 1;
                    else if (p.abs(a.z) < 0.001 && p.abs(b.z) < 0.001) axis = 2;
                    
                    let u = i / N;
                    let armPos, armNeg;
                    
                    if (axis == 0) {
                        armPos = p.createVector(L * u, 0, 0);
                        armNeg = p.createVector(-L * u, 0, 0);
                    }
                    else if (axis == 1) {
                        armPos = p.createVector(0, L * u, 0);
                        armNeg = p.createVector(0, -L * u, 0);
                    }
                    else {
                        armPos = p.createVector(0, 0, L * u);
                        armNeg = p.createVector(0, 0, -L * u);
                    }
                    
                    p.stroke(c);
                    p.line(dpt.x, dpt.y, dpt.z, armPos.x, armPos.y, armPos.z);
                    p.line(dpt.x, dpt.y, dpt.z, armNeg.x, armNeg.y, armNeg.z);
                }
            }
            
            p.push();
            p.camera();
            p.fill(255);
            p.textSize(12);
            p.textAlign(p.LEFT, p.TOP);
            p.text("YZ + XZ planes", -p.width/2 + 10, -p.height/2 + 10);
            p.pop();
        }
        
        p.mousePressed = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
                autoRotate = false;
                lastInteractionTime = p.millis();
            }
        }
        
        p.mouseDragged = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                autoRotate = false;
                lastInteractionTime = p.millis();
                let dx = (p.mouseX - lastMouseX) * 0.01;
                let dy = (p.mouseY - lastMouseY) * 0.01;
                rotY += dx;
                rotX += dy;
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
            }
        }
        
        p.mouseWheel = function(event) {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                zoom += event.delta * 5;
                return false;
            }
        }
    };
    
    // Third sketch - YZ + XZ + XY planes (all 12 diagonals)
    let sketch3 = function(p) {
        let L = 120;
        let pts = [];
        let edges = [];
        let N = 40;
        let rotX = 0, rotY = 0;
        let lastMouseX, lastMouseY;
        let zoom = 0;
        let autoRotate = true;
        let lastInteractionTime = 0;
        let diagColors = [];
        
        p.setup = function() {
            let canvas = p.createCanvas(600, 450, p.WEBGL);
            canvas.parent('sketch-container3');
            
            diagColors = [
                p.color(255, 100, 100),
                p.color(100, 255, 120),
                p.color(120, 150, 255),
                p.color(255, 220, 120),
                p.color(255, 150, 200),
                p.color(150, 255, 255),
                p.color(200, 150, 255),
                p.color(255, 200, 100),
                p.color(150, 255, 150),
                p.color(255, 255, 150),
                p.color(150, 200, 255),
                p.color(255, 180, 180)
            ];
            
            pts = [
                p.createVector(L, 0, 0),
                p.createVector(-L, 0, 0),
                p.createVector(0, L, 0),
                p.createVector(0, -L, 0),
                p.createVector(0, 0, L),
                p.createVector(0, 0, -L)
            ];
            
            edges = [];
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    if (p.abs(p5.Vector.dot(pts[i], pts[j])) < 0.001) {
                        let isYZ = p.abs(pts[i].x) < 0.001 && p.abs(pts[j].x) < 0.001;
                        let isXZ = p.abs(pts[i].y) < 0.001 && p.abs(pts[j].y) < 0.001;
                        let isXY = p.abs(pts[i].z) < 0.001 && p.abs(pts[j].z) < 0.001;
                        
                        if (isYZ) {
                            if (pts[i].y < pts[j].y || (p.abs(pts[i].y - pts[j].y) < 0.001 && pts[i].z < pts[j].z)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        } else if (isXZ) {
                            if (pts[i].x < pts[j].x || (p.abs(pts[i].x - pts[j].x) < 0.001 && pts[i].z < pts[j].z)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        } else if (isXY) {
                            if (pts[i].x < pts[j].x || (p.abs(pts[i].x - pts[j].x) < 0.001 && pts[i].y < pts[j].y)) {
                                edges.push([i, j]);
                            } else {
                                edges.push([j, i]);
                            }
                        }
                    }
                }
            }
        }
        
        p.draw = function() {
            p.background(40, 40, 40);
            
            if (p.millis() - lastInteractionTime > 2000) {
                autoRotate = true;
            }
            
            if (autoRotate) {
                rotY += p.TWO_PI / 2400;
            }
            
            p.translate(0, 0, -50 + zoom);
            p.rotateX(rotX);
            p.rotateY(rotY);
            
            p.strokeWeight(5);
            p.stroke(0, 0, 0);
            for (let pt of pts) {
                p.line(0, 0, 0, pt.x, pt.y, pt.z);
            }
            
            p.strokeWeight(0.45);
            for (let idx = 0; idx < edges.length; idx++) {
                let e = edges[idx];
                let a = pts[e[0]];
                let b = pts[e[1]];
                let c = diagColors[idx];
                
                p.stroke(c);
                p.line(a.x, a.y, a.z, b.x, b.y, b.z);
                
                for (let i = 0; i <= N; i++) {
                    let t = i / N;
                    let dpt = p5.Vector.lerp(a, b, t);
                    
                    let axis = -1;
                    if (p.abs(a.x) < 0.001 && p.abs(b.x) < 0.001) axis = 0;
                    else if (p.abs(a.y) < 0.001 && p.abs(b.y) < 0.001) axis = 1;
                    else if (p.abs(a.z) < 0.001 && p.abs(b.z) < 0.001) axis = 2;
                    
                    let u = i / N;
                    let armPos, armNeg;
                    
                    if (axis == 0) {
                        armPos = p.createVector(L * u, 0, 0);
                        armNeg = p.createVector(-L * u, 0, 0);
                    }
                    else if (axis == 1) {
                        armPos = p.createVector(0, L * u, 0);
                        armNeg = p.createVector(0, -L * u, 0);
                    }
                    else {
                        armPos = p.createVector(0, 0, L * u);
                        armNeg = p.createVector(0, 0, -L * u);
                    }
                    
                    p.stroke(c);
                    p.line(dpt.x, dpt.y, dpt.z, armPos.x, armPos.y, armPos.z);
                    p.line(dpt.x, dpt.y, dpt.z, armNeg.x, armNeg.y, armNeg.z);
                }
            }
            
            p.push();
            p.camera();
            p.fill(255);
            p.textSize(12);
            p.textAlign(p.LEFT, p.TOP);
            p.text("All 3 planes (12 diagonals)", -p.width/2 + 10, -p.height/2 + 10);
            p.pop();
        }
        
        p.mousePressed = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
                autoRotate = false;
                lastInteractionTime = p.millis();
            }
        }
        
        p.mouseDragged = function() {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                autoRotate = false;
                lastInteractionTime = p.millis();
                let dx = (p.mouseX - lastMouseX) * 0.01;
                let dy = (p.mouseY - lastMouseY) * 0.01;
                rotY += dx;
                rotX += dy;
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
            }
        }
        
        p.mouseWheel = function(event) {
            if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                zoom += event.delta * 5;
                return false;
            }
        }
    };
    
    new p5(sketch1);
    new p5(sketch2);
    new p5(sketch3);
</script>